<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Pong + Algoritmo Gen√©tico em JavaScript</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }

    h1, h2 {
      margin: 8px 0;
    }

    #container {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 16px;
    }

    #gamesRow {
      display: flex;
      flex-direction: row;
      gap: 16px;
      flex-wrap: wrap;
    }

    #leftColumn, #rightColumn {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #leftColumn {
      flex: 1;
      min-width: 380px;
    }

    #rightColumn {
      flex: 1;
      min-width: 380px;
    }

    .gamePanel {
      background: #222;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 0 8px rgba(0,0,0,0.5);
      min-width: 200px;
    }

    .gamePanel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      text-align: center;
    }

    .gamePanel canvas {
      width: 200px;
      height: 150px;
    }

    .panel {
      background: #222;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 0 8px rgba(0,0,0,0.5);
    }

    canvas {
      background: #000;
      border-radius: 4px;
      display: block;
      margin: 0 auto;
    }

    #info {
      font-size: 14px;
      line-height: 1.4;
      white-space: pre-line;
    }

    button {
      background: #444;
      border: none;
      color: #eee;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 8px;
    }

    button:hover {
      background: #666;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .control-group {
      background: #1a1a1a;
      padding: 12px;
      border-radius: 6px;
      border: 1px solid #333;
      transition: border-color 0.2s;
    }

    .control-group:hover {
      border-color: #555;
    }

    .control-group label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #ccc;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .control-group .value-display {
      background: #2a2a2a;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 13px;
      color: #4CAF50;
      font-weight: bold;
      min-width: 60px;
      text-align: center;
      border: 1px solid #3a3a3a;
    }

    .control-group input[type="range"] {
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #4CAF50;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .control-group input[type="range"]::-webkit-slider-thumb:hover {
      background: #5CBF60;
      transform: scale(1.1);
    }

    .control-group input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #4CAF50;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .control-group input[type="range"]::-moz-range-thumb:hover {
      background: #5CBF60;
      transform: scale(1.1);
    }

    .control-group input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      background: #333;
      border-radius: 3px;
    }

    .control-group input[type="range"]::-moz-range-track {
      height: 6px;
      background: #333;
      border-radius: 3px;
    }

    .apply-button-container {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #333;
      text-align: center;
    }

    .btn-apply {
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: white;
      padding: 10px 24px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
      width: 100%;
    }

    .btn-apply:hover {
      background: linear-gradient(135deg, #5CBF60, #4CAF50);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
      transform: translateY(-1px);
    }

    .btn-apply:active {
      transform: translateY(0);
    }

    .btn-apply:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
      box-shadow: none;
    }

    .pending-changes {
      font-size: 11px;
      color: #FFC107;
      margin-top: 8px;
      text-align: center;
      font-style: italic;
    }

    .info-section {
      background: #1a1a1a;
      border-left: 3px solid #4CAF50;
      padding: 10px;
      margin: 12px 0;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.6;
    }

    .info-section h3 {
      margin: 0 0 8px 0;
      color: #4CAF50;
      font-size: 14px;
    }

    .info-section ul {
      margin: 8px 0;
      padding-left: 20px;
    }

    .info-section li {
      margin: 4px 0;
    }

    .controls-section {
      border-top: 1px solid #333;
      margin-top: 12px;
      padding-top: 12px;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="leftColumn">
      <div class="panel">
        <h1>Pong + Algoritmo Gen√©tico</h1>
        <div id="info"></div>
        <div style="margin-top:8px;">
          <button id="toggleTrainingBtn">Pausar Treinamento</button>
          <button id="resetBtn">Resetar Popula√ß√£o</button>
        </div>

        <div class="info-section">
          <h3>üìö Como Funciona o Treinamento</h3>
          <ul>
            <li><strong>Algoritmo Gen√©tico:</strong> Evolui uma popula√ß√£o de redes neurais atrav√©s de sele√ß√£o, crossover e muta√ß√£o.</li>
            <li><strong>Fitness:</strong> Cada rede joga Pong e recebe pontos baseados em tempo de sobreviv√™ncia e rebatidas.</li>
            <li><strong>Sele√ß√£o:</strong> Os melhores indiv√≠duos s√£o preservados (elitismo) e usados para criar a pr√≥xima gera√ß√£o.</li>
            <li><strong>Crossover:</strong> Combina genes de dois pais para criar filhos.</li>
            <li><strong>Muta√ß√£o:</strong> Adiciona varia√ß√£o aleat√≥ria para explorar novas solu√ß√µes.</li>
          </ul>
        </div>

        <div class="controls-section">
          <h3 style="margin-top:0; margin-bottom:16px; font-size:14px; color:#4CAF50;">‚öôÔ∏è Par√¢metros do Algoritmo</h3>
          
          <div class="controls-grid">
            <div class="control-group">
              <label>
                <span>Tamanho da Popula√ß√£o</span>
                <span class="value-display" id="popSizeValue">30</span>
              </label>
              <input type="range" id="popSizeSlider" min="10" max="100" value="30" step="5">
            </div>

            <div class="control-group">
              <label>
                <span>N√∫mero de Elites</span>
                <span class="value-display" id="eliteCountValue">4</span>
              </label>
              <input type="range" id="eliteCountSlider" min="1" max="10" value="4" step="1">
            </div>

            <div class="control-group">
              <label>
                <span>Taxa de Muta√ß√£o</span>
                <span class="value-display" id="mutationRateValue">0.15</span>
              </label>
              <input type="range" id="mutationRateSlider" min="0.05" max="0.5" value="0.15" step="0.05">
            </div>

            <div class="control-group">
              <label>
                <span>Desvio Padr√£o da Muta√ß√£o</span>
                <span class="value-display" id="mutationStdValue">0.3</span>
              </label>
              <input type="range" id="mutationStdSlider" min="0.1" max="1.0" value="0.3" step="0.1">
            </div>

            <div class="control-group">
              <label>
                <span>Epis√≥dios por Genoma</span>
                <span class="value-display" id="episodesValue">2</span>
              </label>
              <input type="range" id="episodesSlider" min="1" max="5" value="2" step="1">
            </div>

            <div class="control-group">
              <label>
                <span>M√°x. Passos por Epis√≥dio</span>
                <span class="value-display" id="maxStepsValue">600</span>
              </label>
              <input type="range" id="maxStepsSlider" min="200" max="1000" value="600" step="100">
            </div>
          </div>

          <div class="apply-button-container">
            <button id="applyParamsBtn" class="btn-apply">Aplicar Par√¢metros</button>
            <div id="pendingChangesMsg" class="pending-changes" style="display:none;">
              ‚ö†Ô∏è Altera√ß√µes pendentes - clique em "Aplicar Par√¢metros" para aplicar
            </div>
          </div>
        </div>
      </div>
      <div class="panel">
        <h2>Todos os Jogos</h2>
        <div id="gamesRow">
          <div class="gamePanel">
            <h3>Principal (melhor)</h3>
            <canvas id="pongCanvas" width="200" height="150"></canvas>
          </div>
          <div class="gamePanel">
            <h3>Jogo 1</h3>
            <canvas id="game1Canvas" width="200" height="150"></canvas>
          </div>
          <div class="gamePanel">
            <h3>Jogo 2</h3>
            <canvas id="game2Canvas" width="200" height="150"></canvas>
          </div>
          <div class="gamePanel">
            <h3>Jogo 3</h3>
            <canvas id="game3Canvas" width="200" height="150"></canvas>
          </div>
        </div>
      </div>
    </div>

    <div id="rightColumn">
      <div class="panel">
        <h2>Rede Neural (melhor indiv√≠duo)</h2>
        <canvas id="nnCanvas" width="400" height="300"></canvas>
      </div>
      <div class="panel">
        <h2>Evolu√ß√£o do Fitness</h2>
        <canvas id="plotCanvas" width="400" height="300"></canvas>
      </div>
    </div>
  </div>

  <script>
    /*************************************************
     * CONFIGURA√á√ïES GERAIS
     *************************************************/
    const LARGURA_PONG = 400;
    const ALTURA_PONG = 300;

    // AG - Vari√°veis mut√°veis (podem ser alteradas pelos controles)
    let TAMANHO_POPULACAO = 30;
    let NUMERO_ELITES = 4;
    let TAXA_MUTACAO = 0.15;
    let DESVIO_PADRAO_MUTACAO = 0.3;

    let EPISODIOS_POR_GENOMA = 2;
    let MAX_PASSOS_POR_EPISODIO = 600;

    // Rede neural (entrada -> oculto -> sa√≠da)
    const TAMANHO_ENTRADA = 6;
    const TAMANHO_OCULTO = 8;
    const TAMANHO_SAIDA = 1;

    /*************************************************
     * FUN√á√ïES AUXILIARES
     *************************************************/
    function aleatorioIntervalo(min, max) {
      return Math.random() * (max - min) + min;
    }

    // Normal (Gaussiana) ~ N(0,1)
    function aleatorioNormal() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    /*************************************************
     * CLASSE DA REDE NEURAL
     *************************************************/
    class RedeNeural {
      constructor(tamanhoEntrada, tamanhoOculto, tamanhoSaida) {
        this.tamanhoEntrada = tamanhoEntrada;
        this.tamanhoOculto = tamanhoOculto;
        this.tamanhoSaida = tamanhoSaida;

        // Pesos e vieses (bias)
        this.pesos1 = new Float64Array(tamanhoEntrada * tamanhoOculto);
        this.vies1 = new Float64Array(tamanhoOculto);
        this.pesos2 = new Float64Array(tamanhoOculto * tamanhoSaida);
        this.vies2 = new Float64Array(tamanhoSaida);
      }

      get tamanhoGenoma() {
        return this.pesos1.length + this.vies1.length + this.pesos2.length + this.vies2.length;
      }

      // Carrega pesos a partir de um vetor genoma
      carregarDoGenoma(genoma) {
        let indice = 0;
        for (let i = 0; i < this.pesos1.length; i++) this.pesos1[i] = genoma[indice++];
        for (let i = 0; i < this.vies1.length; i++) this.vies1[i] = genoma[indice++];
        for (let i = 0; i < this.pesos2.length; i++) this.pesos2[i] = genoma[indice++];
        for (let i = 0; i < this.vies2.length; i++) this.vies2[i] = genoma[indice++];
      }

      // Ativa√ß√£o tanh
      tanh(x) {
        return Math.tanh(x);
      }

      // Forward: entrada -> sa√≠da
      propagar(entrada) {
        const oculto = new Float64Array(this.tamanhoOculto);
        const saida = new Float64Array(this.tamanhoSaida);

        // Camada oculta
        for (let h = 0; h < this.tamanhoOculto; h++) {
          let soma = this.vies1[h];
          for (let i = 0; i < this.tamanhoEntrada; i++) {
            soma += entrada[i] * this.pesos1[h * this.tamanhoEntrada + i];
          }
          oculto[h] = this.tanh(soma);
        }

        // Camada de sa√≠da
        for (let o = 0; o < this.tamanhoSaida; o++) {
          let soma = this.vies2[o];
          for (let h = 0; h < this.tamanhoOculto; h++) {
            soma += oculto[h] * this.pesos2[o * this.tamanhoOculto + h];
          }
          saida[o] = this.tanh(soma);
        }

        return { oculto, saida };
      }
    }

    /*************************************************
     * AMBIENTE PONG
     * - Agente controla a raquete esquerda
     * - Raquete direita √© uma IA simples que segue a bola
     *************************************************/
    class AmbientePong {
      constructor(largura, altura) {
        this.largura = largura;
        this.altura = altura;

        this.alturaRaquete = 50;
        this.larguraRaquete = 8;
        this.velocidadeRaquete = 6;

        this.raioBola = 5;
        this.velocidadeBola = 5.0;

        this.reiniciar();
      }

      reiniciar() {
        // Raquete esquerda (agente)
        this.posYRaquete = this.altura / 2;

        // Raquete direita (inimigo simples)
        this.posYRaqueteInimiga = this.altura / 2;

        // Bola
        this.posXBola = this.largura / 2;
        this.posYBola = this.altura / 2;
        const angulo = aleatorioIntervalo(-0.4 * Math.PI, 0.4 * Math.PI);
        const direcao = Math.random() < 0.5 ? -1 : 1;
        this.velXBola = Math.cos(angulo) * this.velocidadeBola * direcao;
        this.velYBola = Math.sin(angulo) * this.velocidadeBola;

        this.rebatidas = 0;
        this.passos = 0;

        return this._obterEstado();
      }

      // Estado normalizado para a rede neural
      _obterEstado() {
        return [
          (this.posXBola / this.largura) * 2 - 1,      // pos X bola [-1,1]
          (this.posYBola / this.altura) * 2 - 1,     // pos Y bola [-1,1]
          this.velXBola / this.velocidadeBola,           // vel X bola [-1,1]
          this.velYBola / this.velocidadeBola,           // vel Y bola [-1,1]
          (this.posYRaquete / this.altura) * 2 - 1,   // pos Y raquete [-1,1]
          ((this.posYBola - this.posYRaquete) / this.altura) // diferen√ßa de Y
        ];
      }

      // acao ‚àà [-1,1] (negativo: sobe, positivo: desce)
      passo(acao) {
        this.passos++;

        // Atualiza raquete do agente
        const dy = acao * this.velocidadeRaquete;
        this.posYRaquete += dy;
        const metadeAlturaRaquete = this.alturaRaquete / 2;
        if (this.posYRaquete < metadeAlturaRaquete) this.posYRaquete = metadeAlturaRaquete;
        if (this.posYRaquete > this.altura - metadeAlturaRaquete) this.posYRaquete = this.altura - metadeAlturaRaquete;

        // Atualiza raquete inimiga (segue bola)
        if (this.posYBola < this.posYRaqueteInimiga - 5) this.posYRaqueteInimiga -= this.velocidadeRaquete * 0.9;
        if (this.posYBola > this.posYRaqueteInimiga + 5) this.posYRaqueteInimiga += this.velocidadeRaquete * 0.9;
        if (this.posYRaqueteInimiga < metadeAlturaRaquete) this.posYRaqueteInimiga = metadeAlturaRaquete;
        if (this.posYRaqueteInimiga > this.altura - metadeAlturaRaquete) this.posYRaqueteInimiga = this.altura - metadeAlturaRaquete;

        // Atualiza bola
        this.posXBola += this.velXBola;
        this.posYBola += this.velYBola;

        // Colis√£o com topo/base
        if (this.posYBola < this.raioBola) {
          this.posYBola = this.raioBola;
          this.velYBola *= -1;
        }
        if (this.posYBola > this.altura - this.raioBola) {
          this.posYBola = this.altura - this.raioBola;
          this.velYBola *= -1;
        }

        let terminado = false;

        // Colis√£o com raquete esquerda (agente)
        if (this.posXBola - this.raioBola < this.larguraRaquete) {
          const minY = this.posYRaquete - metadeAlturaRaquete;
          const maxY = this.posYRaquete + metadeAlturaRaquete;
          if (this.posYBola >= minY && this.posYBola <= maxY) {
            this.posXBola = this.larguraRaquete + this.raioBola;
            this.velXBola *= -1;
            this.rebatidas++;

            // Pequena acelera√ß√£o a cada rebatida
            this.velXBola *= 1.03;
            this.velYBola *= 1.03;
          } else {
            // Bola passou da raquete (derrota)
            terminado = true;
          }
        }

        // Colis√£o com raquete direita
        if (this.posXBola + this.raioBola > this.largura - this.larguraRaquete) {
          const minY = this.posYRaqueteInimiga - metadeAlturaRaquete;
          const maxY = this.posYRaqueteInimiga + metadeAlturaRaquete;
          if (this.posYBola >= minY && this.posYBola <= maxY) {
            this.posXBola = this.largura - this.larguraRaquete - this.raioBola;
            this.velXBola *= -1;
            this.velXBola *= 1.03;
            this.velYBola *= 1.03;
          } else {
            // Se passar da direita, apenas rebate na parede
            if (this.posXBola > this.largura - this.raioBola) {
              this.posXBola = this.largura - this.raioBola;
              this.velXBola *= -1;
            }
          }
        }

        const estado = this._obterEstado();
        return { estado, terminado };
      }
    }

    /*************************************************
     * AVALIA√á√ÉO DO GENOMA
     * - Fitness baseado em tempo de sobreviv√™ncia + rebatidas
     *************************************************/
    function avaliarGenoma(genoma, rede) {
      rede.carregarDoGenoma(genoma);

      let fitnessTotal = 0;

      for (let ep = 0; ep < EPISODIOS_POR_GENOMA; ep++) {
        const ambiente = new AmbientePong(LARGURA_PONG, ALTURA_PONG);
        let terminado = false;
        let passos = 0;

        while (!terminado && passos < MAX_PASSOS_POR_EPISODIO) {
          const estado = ambiente._obterEstado();
          const { saida } = rede.propagar(estado);
          const acao = saida[0]; // j√° est√° em [-1,1] pelo tanh

          const resultado = ambiente.passo(acao);
          terminado = resultado.terminado;
          passos++;
        }

        const fitness = passos + ambiente.rebatidas * 200;
        fitnessTotal += fitness;
      }

      return fitnessTotal / EPISODIOS_POR_GENOMA;
    }

    /*************************************************
     * ALGORITMO GEN√âTICO
     *************************************************/
    class AlgoritmoGenetico {
      constructor(tamanhoPopulacao, tamanhoGenoma) {
        this.tamanhoPopulacao = tamanhoPopulacao;
        this.tamanhoGenoma = tamanhoGenoma;

        this.populacao = [];
        this.fitnesses = [];
        this.geracao = 0;

        for (let i = 0; i < tamanhoPopulacao; i++) {
          const genoma = new Float64Array(tamanhoGenoma);
          for (let g = 0; g < tamanhoGenoma; g++) {
            genoma[g] = aleatorioIntervalo(-1, 1);
          }
          this.populacao.push(genoma);
          this.fitnesses.push(0);
        }
      }

      avaliarPopulacao(avaliador) {
        let melhorFitness = -Infinity;
        let melhorIndice = 0;
        let fitnessMedio = 0;

        for (let i = 0; i < this.tamanhoPopulacao; i++) {
          const fit = avaliador(this.populacao[i]);
          this.fitnesses[i] = fit;
          fitnessMedio += fit;

          if (fit > melhorFitness) {
            melhorFitness = fit;
            melhorIndice = i;
          }
        }

        fitnessMedio /= this.tamanhoPopulacao;
        return { melhorFitness, melhorIndice, fitnessMedio };
      }

      // Sele√ß√£o por torneio
      _selecaoTorneio(k = 3) {
        let melhor = -1;
        let melhorFit = -Infinity;
        for (let i = 0; i < k; i++) {
          const indice = Math.floor(Math.random() * this.tamanhoPopulacao);
          if (this.fitnesses[indice] > melhorFit) {
            melhorFit = this.fitnesses[indice];
            melhor = indice;
          }
        }
        return this.populacao[melhor];
      }

      // Crossover de um ponto
      _crossover(pai1, pai2) {
        const filho = new Float64Array(this.tamanhoGenoma);
        const ponto = Math.floor(Math.random() * this.tamanhoGenoma);
        for (let i = 0; i < this.tamanhoGenoma; i++) {
          if (i < ponto) filho[i] = pai1[i];
          else filho[i] = pai2[i];
        }
        return filho;
      }

      // Muta√ß√£o gaussiana
      _mutar(genoma) {
        for (let i = 0; i < this.tamanhoGenoma; i++) {
          if (Math.random() < TAXA_MUTACAO) {
            genoma[i] += aleatorioNormal() * DESVIO_PADRAO_MUTACAO;
          }
        }
      }

      proximaGeracao() {
        // Ordena por fitness
        const indices = Array.from(this.populacao.keys());
        indices.sort((a, b) => this.fitnesses[b] - this.fitnesses[a]);

        const novaPop = [];

        // Elitismo
        for (let i = 0; i < NUMERO_ELITES; i++) {
          const genomaElite = new Float64Array(this.populacao[indices[i]]);
          novaPop.push(genomaElite);
        }

        // Reproduz at√© preencher a popula√ß√£o
        while (novaPop.length < this.tamanhoPopulacao) {
          const pai1 = this._selecaoTorneio();
          const pai2 = this._selecaoTorneio();
          let filho = this._crossover(pai1, pai2);
          this._mutar(filho);
          novaPop.push(filho);
        }

        this.populacao = novaPop;
        this.geracao++;
      }

      reiniciar() {
        this.populacao = [];
        this.fitnesses = [];
        this.geracao = 0;

        for (let i = 0; i < this.tamanhoPopulacao; i++) {
          const genoma = new Float64Array(this.tamanhoGenoma);
          for (let g = 0; g < this.tamanhoGenoma; g++) {
            genoma[g] = aleatorioIntervalo(-1, 1);
          }
          this.populacao.push(genoma);
          this.fitnesses.push(0);
        }
      }
    }

    /*************************************************
     * SETUP GLOBAL
     *************************************************/
    const canvasPong = document.getElementById("pongCanvas");
    const ctxPong = canvasPong.getContext("2d");

    const canvasRede = document.getElementById("nnCanvas");
    const ctxRede = canvasRede.getContext("2d");

    const canvasGrafico = document.getElementById("plotCanvas");
    const ctxGrafico = canvasGrafico.getContext("2d");

    const divInfo = document.getElementById("info");
    const btnToggleTreinamento = document.getElementById("toggleTrainingBtn");
    const btnReset = document.getElementById("resetBtn");

    const ambienteVisualizacao = new AmbientePong(200, 150);
    const redeVisualizacao = new RedeNeural(TAMANHO_ENTRADA, TAMANHO_OCULTO, TAMANHO_SAIDA);
    const redeAG = new RedeNeural(TAMANHO_ENTRADA, TAMANHO_OCULTO, TAMANHO_SAIDA);
    const tamanhoGenoma = redeAG.tamanhoGenoma;

    let algoritmoGenetico = new AlgoritmoGenetico(TAMANHO_POPULACAO, tamanhoGenoma);

    let melhorGenoma = new Float64Array(tamanhoGenoma);
    let historicoMelhorFitness = [];
    let historicoFitnessMedio = [];
    let treinando = true;

    // Inst√¢ncias adicionais de jogos
    const ambienteJogo1 = new AmbientePong(200, 150);
    const redeJogo1 = new RedeNeural(TAMANHO_ENTRADA, TAMANHO_OCULTO, TAMANHO_SAIDA);
    const canvasJogo1 = document.getElementById("game1Canvas");
    const ctxJogo1 = canvasJogo1.getContext("2d");

    const ambienteJogo2 = new AmbientePong(200, 150);
    const redeJogo2 = new RedeNeural(TAMANHO_ENTRADA, TAMANHO_OCULTO, TAMANHO_SAIDA);
    const canvasJogo2 = document.getElementById("game2Canvas");
    const ctxJogo2 = canvasJogo2.getContext("2d");

    const ambienteJogo3 = new AmbientePong(200, 150);
    const redeJogo3 = new RedeNeural(TAMANHO_ENTRADA, TAMANHO_OCULTO, TAMANHO_SAIDA);
    const canvasJogo3 = document.getElementById("game3Canvas");
    const ctxJogo3 = canvasJogo3.getContext("2d");

    // Genomas aleat√≥rios para os jogos adicionais
    let genomaJogo1 = new Float64Array(tamanhoGenoma);
    let genomaJogo2 = new Float64Array(tamanhoGenoma);
    let genomaJogo3 = new Float64Array(tamanhoGenoma);
    for (let i = 0; i < tamanhoGenoma; i++) {
      genomaJogo1[i] = aleatorioIntervalo(-1, 1);
      genomaJogo2[i] = aleatorioIntervalo(-1, 1);
      genomaJogo3[i] = aleatorioIntervalo(-1, 1);
    }

    /*************************************************
     * DESENHO DA REDE NEURAL
     *************************************************/
    function desenharRedeNeural(genoma, ativacoes = null) {
      redeVisualizacao.carregarDoGenoma(genoma);

      const ctx = ctxRede;
      ctx.clearRect(0, 0, canvasRede.width, canvasRede.height);

      const marginX = 40;
      const marginY = 40;

      const posicoesX = [
        marginX,
        canvasRede.width / 2,
        canvasRede.width - marginX
      ];

      function posicoesNos(tamanhoCamada, indiceCamada) {
        const x = posicoesX[indiceCamada];
        const posicoes = [];
        const alturaTotal = canvasRede.height - 2 * marginY;
        const passo = alturaTotal / (tamanhoCamada + 1);
        for (let i = 0; i < tamanhoCamada; i++) {
          const y = marginY + (i + 1) * passo;
          posicoes.push({ x, y });
        }
        return posicoes;
      }

      const nosEntrada = posicoesNos(TAMANHO_ENTRADA, 0);
      const nosOculto = posicoesNos(TAMANHO_OCULTO, 1);
      const nosSaida = posicoesNos(TAMANHO_SAIDA, 2);

      // Fun√ß√£o para obter cor baseada na ativa√ß√£o (-1 a 1)
      function obterCorAtivacao(ativacao) {
        // Normaliza de [-1, 1] para [0, 1]
        const normalizado = (ativacao + 1) / 2;
        const intensidade = Math.abs(ativacao);
        
        if (ativacao < 0) {
          // Negativo: azul/roxo (mais escuro = mais negativo)
          const r = Math.floor(intensidade * 100);
          const g = Math.floor(intensidade * 50);
          const b = Math.floor(100 + intensidade * 155);
          return `rgb(${r}, ${g}, ${b})`;
        } else {
          // Positivo: amarelo/verde (mais brilhante = mais positivo)
          const r = Math.floor(200 + intensidade * 55);
          const g = Math.floor(200 + intensidade * 55);
          const b = Math.floor(intensidade * 100);
          return `rgb(${r}, ${g}, ${b})`;
        }
      }

      // Fun√ß√£o para obter tamanho baseado na ativa√ß√£o
      function obterTamanhoNo(ativacao) {
        const intensidade = Math.abs(ativacao);
        return 5 + intensidade * 4; // Tamanho entre 5 e 9
      }

      // Linhas entre entrada -> oculto com espessura baseada nos pesos
      ctx.lineWidth = 0.5;
      for (let i = 0; i < TAMANHO_ENTRADA; i++) {
        for (let h = 0; h < TAMANHO_OCULTO; h++) {
          const peso = redeVisualizacao.pesos1[h * TAMANHO_ENTRADA + i];
          const intensidade = Math.abs(peso);
          ctx.strokeStyle = peso > 0 ? `rgba(0, 255, 0, ${intensidade * 0.3})` : `rgba(255, 0, 0, ${intensidade * 0.3})`;
          ctx.beginPath();
          ctx.moveTo(nosEntrada[i].x, nosEntrada[i].y);
          ctx.lineTo(nosOculto[h].x, nosOculto[h].y);
          ctx.stroke();
        }
      }

      // Linhas entre oculto -> sa√≠da
      for (let h = 0; h < TAMANHO_OCULTO; h++) {
        for (let o = 0; o < TAMANHO_SAIDA; o++) {
          const peso = redeVisualizacao.pesos2[o * TAMANHO_OCULTO + h];
          const intensidade = Math.abs(peso);
          ctx.strokeStyle = peso > 0 ? `rgba(0, 255, 0, ${intensidade * 0.3})` : `rgba(255, 0, 0, ${intensidade * 0.3})`;
          ctx.beginPath();
          ctx.moveTo(nosOculto[h].x, nosOculto[h].y);
          ctx.lineTo(nosSaida[o].x, nosSaida[o].y);
          ctx.stroke();
        }
      }

      // Desenha n√≥s de entrada
      for (let i = 0; i < TAMANHO_ENTRADA; i++) {
        const no = nosEntrada[i];
        const ativacao = ativacoes ? ativacoes.entrada[i] : 0;
        const cor = ativacoes ? obterCorAtivacao(ativacao) : "#4CAF50";
        const tamanho = ativacoes ? obterTamanhoNo(ativacao) : 7;
        
        ctx.fillStyle = cor;
        ctx.beginPath();
        ctx.arc(no.x, no.y, tamanho, 0, Math.PI * 2);
        ctx.fill();
        
        // Borda
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Desenha n√≥s ocultos
      for (let h = 0; h < TAMANHO_OCULTO; h++) {
        const no = nosOculto[h];
        const ativacao = ativacoes ? ativacoes.oculto[h] : 0;
        const cor = ativacoes ? obterCorAtivacao(ativacao) : "#FFC107";
        const tamanho = ativacoes ? obterTamanhoNo(ativacao) : 7;
        
        ctx.fillStyle = cor;
        ctx.beginPath();
        ctx.arc(no.x, no.y, tamanho, 0, Math.PI * 2);
        ctx.fill();
        
        // Borda
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Desenha n√≥s de sa√≠da
      for (let o = 0; o < TAMANHO_SAIDA; o++) {
        const no = nosSaida[o];
        const ativacao = ativacoes ? ativacoes.saida[o] : 0;
        const cor = ativacoes ? obterCorAtivacao(ativacao) : "#03A9F4";
        const tamanho = ativacoes ? obterTamanhoNo(ativacao) : 7;
        
        ctx.fillStyle = cor;
        ctx.beginPath();
        ctx.arc(no.x, no.y, tamanho, 0, Math.PI * 2);
        ctx.fill();
        
        // Borda
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Legendas
      ctx.fillStyle = "#eee";
      ctx.font = "12px Arial";
      ctx.fillText("Entradas", nosEntrada[0].x - 20, 20);
      ctx.fillText("Oculta", nosOculto[0].x - 15, 20);
      ctx.fillText("Sa√≠da", nosSaida[0].x - 10, 20);
    }

    /*************************************************
     * DESENHO DO PONG (MELHOR INDIV√çDUO)
     *************************************************/
    function desenharPong(ambiente, ctx, largura, altura) {
      ctx.clearRect(0, 0, largura, altura);

      // Fundo
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, largura, altura);

      // Linha central
      ctx.strokeStyle = "#333";
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(largura / 2, 0);
      ctx.lineTo(largura / 2, altura);
      ctx.stroke();
      ctx.setLineDash([]);

      // Raquete esquerda
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(
        0,
        ambiente.posYRaquete - ambiente.alturaRaquete / 2,
        ambiente.larguraRaquete,
        ambiente.alturaRaquete
      );

      // Raquete direita
      ctx.fillStyle = "#aaaaaa";
      ctx.fillRect(
        largura - ambiente.larguraRaquete,
        ambiente.posYRaqueteInimiga - ambiente.alturaRaquete / 2,
        ambiente.larguraRaquete,
        ambiente.alturaRaquete
      );

      // Bola
      ctx.beginPath();
      ctx.arc(ambiente.posXBola, ambiente.posYBola, ambiente.raioBola, 0, Math.PI * 2);
      ctx.fillStyle = "#fff";
      ctx.fill();

      // Info no canvas
      ctx.fillStyle = "#0f0";
      ctx.font = "10px Arial";
      ctx.fillText("Rebatidas: " + ambiente.rebatidas, 5, 12);
    }

    function desenharPongPrincipal() {
      desenharPong(ambienteVisualizacao, ctxPong, 200, 150);
    }

    let ativacoesAtuais = null;

    function atualizarVisualizacaoPong() {
      // Usa o melhor genoma atual
      redeVisualizacao.carregarDoGenoma(melhorGenoma);
      const estado = ambienteVisualizacao._obterEstado();
      const { oculto, saida } = redeVisualizacao.propagar(estado);
      const acao = saida[0];

      // Salva as ativa√ß√µes para visualiza√ß√£o
      ativacoesAtuais = {
        entrada: estado,
        oculto: Array.from(oculto),
        saida: Array.from(saida)
      };

      const resultado = ambienteVisualizacao.passo(acao);
      if (resultado.terminado) {
        ambienteVisualizacao.reiniciar();
      }
    }

    function atualizarJogo(ambiente, rede, genoma) {
      rede.carregarDoGenoma(genoma);
      const estado = ambiente._obterEstado();
      const { saida } = rede.propagar(estado);
      const acao = saida[0];

      const resultado = ambiente.passo(acao);
      if (resultado.terminado) {
        ambiente.reiniciar();
      }
    }

    /*************************************************
     * DESENHO DO GR√ÅFICO DE EVOLU√á√ÉO
     *************************************************/
    function desenharGraficoFitness() {
      const ctx = ctxGrafico;
      const w = canvasGrafico.width;
      const h = canvasGrafico.height;

      ctx.clearRect(0, 0, w, h);

      // Fundo com gradiente
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, "#1a1a1a");
      gradient.addColorStop(1, "#000");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);

      const marginLeft = 50;
      const marginRight = 10;
      const marginTop = 20;
      const marginBottom = 35;
      const plotWidth = w - marginLeft - marginRight;
      const plotHeight = h - marginTop - marginBottom;
      const plotX = marginLeft;
      const plotY = marginTop;

      // Grade de fundo
      ctx.strokeStyle = "#222";
      ctx.lineWidth = 1;
      const gridLines = 5;
      for (let i = 0; i <= gridLines; i++) {
        const y = plotY + (i / gridLines) * plotHeight;
        ctx.beginPath();
        ctx.moveTo(plotX, y);
        ctx.lineTo(plotX + plotWidth, y);
        ctx.stroke();
      }
      for (let i = 0; i <= gridLines; i++) {
        const x = plotX + (i / gridLines) * plotWidth;
        ctx.beginPath();
        ctx.moveTo(x, plotY);
        ctx.lineTo(x, plotY + plotHeight);
        ctx.stroke();
      }

      // Eixos principais
      ctx.strokeStyle = "#555";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(plotX, plotY);
      ctx.lineTo(plotX, plotY + plotHeight);
      ctx.lineTo(plotX + plotWidth, plotY + plotHeight);
      ctx.stroke();

      if (historicoMelhorFitness.length === 0) {
        // Mostra mensagem quando n√£o h√° dados
        ctx.fillStyle = "#666";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Aguardando dados...", w / 2, h / 2);
        ctx.textAlign = "left";
        return;
      }

      const maxGen = historicoMelhorFitness.length - 1;
      const allFitness = [...historicoMelhorFitness, ...historicoFitnessMedio];
      const maxFit = Math.max(...allFitness);
      const minFit = Math.min(...allFitness);
      const fitRange = Math.max(1, maxFit - minFit);
      const padding = fitRange * 0.1; // 10% de padding

      function xFromGen(gen) {
        if (maxGen === 0) return plotX;
        return plotX + (gen / maxGen) * plotWidth;
      }

      function yFromFit(f) {
        const norm = (f - (minFit - padding)) / (fitRange + 2 * padding);
        return plotY + plotHeight - norm * plotHeight;
      }

      // √Årea preenchida sob a curva do melhor fitness
      if (historicoMelhorFitness.length > 1) {
        const gradientBest = ctx.createLinearGradient(0, plotY, 0, plotY + plotHeight);
        gradientBest.addColorStop(0, "rgba(0, 255, 0, 0.3)");
        gradientBest.addColorStop(1, "rgba(0, 255, 0, 0.05)");
        ctx.fillStyle = gradientBest;
        ctx.beginPath();
        ctx.moveTo(xFromGen(0), plotY + plotHeight);
        for (let i = 0; i < historicoMelhorFitness.length; i++) {
          const x = xFromGen(i);
          const y = yFromFit(historicoMelhorFitness[i]);
          ctx.lineTo(x, y);
        }
        ctx.lineTo(xFromGen(maxGen), plotY + plotHeight);
        ctx.closePath();
        ctx.fill();
      }

      // √Årea preenchida sob a curva do fitness m√©dio
      if (historicoFitnessMedio.length > 1) {
        const gradientAvg = ctx.createLinearGradient(0, plotY, 0, plotY + plotHeight);
        gradientAvg.addColorStop(0, "rgba(255, 255, 0, 0.2)");
        gradientAvg.addColorStop(1, "rgba(255, 255, 0, 0.05)");
        ctx.fillStyle = gradientAvg;
        ctx.beginPath();
        ctx.moveTo(xFromGen(0), plotY + plotHeight);
        for (let i = 0; i < historicoFitnessMedio.length; i++) {
          const x = xFromGen(i);
          const y = yFromFit(historicoFitnessMedio[i]);
          ctx.lineTo(x, y);
        }
        ctx.lineTo(xFromGen(maxGen), plotY + plotHeight);
        ctx.closePath();
        ctx.fill();
      }

      // Curva do melhor fitness (verde brilhante)
      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2.5;
      ctx.shadowBlur = 5;
      ctx.shadowColor = "rgba(0, 255, 0, 0.5)";
      ctx.beginPath();
      for (let i = 0; i < historicoMelhorFitness.length; i++) {
        const x = xFromGen(i);
        const y = yFromFit(historicoMelhorFitness[i]);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Curva do fitness m√©dio (amarelo)
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 2;
      ctx.shadowBlur = 3;
      ctx.shadowColor = "rgba(255, 215, 0, 0.3)";
      ctx.beginPath();
      for (let i = 0; i < historicoFitnessMedio.length; i++) {
        const x = xFromGen(i);
        const y = yFromFit(historicoFitnessMedio[i]);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Pontos nos √∫ltimos valores
      if (historicoMelhorFitness.length > 0) {
        const lastX = xFromGen(maxGen);
        const lastY = yFromFit(historicoMelhorFitness[historicoMelhorFitness.length - 1]);
        ctx.fillStyle = "#00FF00";
        ctx.beginPath();
        ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      if (historicoFitnessMedio.length > 0) {
        const lastX = xFromGen(maxGen);
        const lastY = yFromFit(historicoFitnessMedio[historicoFitnessMedio.length - 1]);
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Marcadores no eixo Y
      ctx.fillStyle = "#888";
      ctx.font = "10px Arial";
      ctx.textAlign = "right";
      for (let i = 0; i <= gridLines; i++) {
        const value = minFit - padding + (fitRange + 2 * padding) * (1 - i / gridLines);
        const y = plotY + (i / gridLines) * plotHeight;
        ctx.fillText(value.toFixed(0), plotX - 5, y + 3);
      }

      // Marcadores no eixo X
      ctx.textAlign = "center";
      const xLabels = Math.min(5, maxGen + 1);
      for (let i = 0; i < xLabels; i++) {
        const gen = Math.floor((i / (xLabels - 1)) * maxGen);
        const x = xFromGen(gen);
        ctx.fillText(gen.toString(), x, plotY + plotHeight + 15);
      }

      // T√≠tulos dos eixos
      ctx.fillStyle = "#fff";
      ctx.font = "12px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Gera√ß√µes", w / 2, h - 5);
      ctx.save();
      ctx.translate(15, h / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText("Fitness", 0, 0);
      ctx.restore();
      ctx.textAlign = "left";

      // Legenda melhorada
      const legendX = w - 130;
      const legendY = 15;
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(legendX - 5, legendY - 5, 125, 45);

      ctx.fillStyle = "#00FF00";
      ctx.fillRect(legendX, legendY, 10, 10);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 1;
      ctx.strokeRect(legendX, legendY, 10, 10);
      ctx.fillStyle = "#fff";
      ctx.font = "11px Arial";
      ctx.fillText("Melhor", legendX + 15, legendY + 8);
      if (historicoMelhorFitness.length > 0) {
        ctx.fillStyle = "#aaa";
        ctx.font = "9px Arial";
        ctx.fillText(historicoMelhorFitness[historicoMelhorFitness.length - 1].toFixed(1), legendX + 15, legendY + 18);
      }

      ctx.fillStyle = "#FFD700";
      ctx.fillRect(legendX, legendY + 20, 10, 10);
      ctx.strokeStyle = "#fff";
      ctx.strokeRect(legendX, legendY + 20, 10, 10);
      ctx.fillStyle = "#fff";
      ctx.font = "11px Arial";
      ctx.fillText("M√©dia", legendX + 15, legendY + 28);
      if (historicoFitnessMedio.length > 0) {
        ctx.fillStyle = "#aaa";
        ctx.font = "9px Arial";
        ctx.fillText(historicoFitnessMedio[historicoFitnessMedio.length - 1].toFixed(1), legendX + 15, legendY + 38);
      }

      // Valores min/max
      ctx.fillStyle = "#666";
      ctx.font = "9px Arial";
      ctx.textAlign = "left";
      ctx.fillText(`Max: ${maxFit.toFixed(1)}`, plotX, 12);
      ctx.fillText(`Min: ${minFit.toFixed(1)}`, plotX, 22);
    }

    /*************************************************
     * LOOP DE TREINAMENTO (GA)
     *************************************************/
    function trainingStep() {
      if (!treinando) return;

      const { melhorFitness, melhorIndice, fitnessMedio } = algoritmoGenetico.avaliarPopulacao((genome) => {
        return avaliarGenoma(genome, redeAG); 
      });

      // Atualiza melhor genoma global
      melhorGenoma = new Float64Array(algoritmoGenetico.populacao[melhorIndice]);

      historicoMelhorFitness.push(melhorFitness);
      historicoFitnessMedio.push(fitnessMedio);

      algoritmoGenetico.proximaGeracao();

      // Atualiza info textual
      divInfo.textContent =
        `Gera√ß√£o: ${algoritmoGenetico.geracao}\n` +
        `Melhor fitness: ${melhorFitness.toFixed(1)}\n` +
        `Fitness m√©dio: ${fitnessMedio.toFixed(1)}\n` +
        `Popula√ß√£o: ${TAMANHO_POPULACAO}`;

      // Atualiza visualiza√ß√µes
      desenharRedeNeural(melhorGenoma, ativacoesAtuais);
      desenharGraficoFitness();
    }

    /*************************************************
     * LOOP DE ANIMA√á√ÉO (JOGO)
     *************************************************/
    function loopAnimacao() {
      // Jogo principal
      atualizarVisualizacaoPong();
      desenharPongPrincipal();

      // Atualiza visualiza√ß√£o da rede neural com ativa√ß√µes
      desenharRedeNeural(melhorGenoma, ativacoesAtuais);

      // Jogos adicionais
      atualizarJogo(ambienteJogo1, redeJogo1, genomaJogo1);
      desenharPong(ambienteJogo1, ctxJogo1, 200, 150);

      atualizarJogo(ambienteJogo2, redeJogo2, genomaJogo2);
      desenharPong(ambienteJogo2, ctxJogo2, 200, 150);

      atualizarJogo(ambienteJogo3, redeJogo3, genomaJogo3);
      desenharPong(ambienteJogo3, ctxJogo3, 200, 150);

      requestAnimationFrame(loopAnimacao);
    }

    /*************************************************
     * CONTROLES
     *************************************************/
    btnToggleTreinamento.addEventListener("click", () => {
      treinando = !treinando;
      btnToggleTreinamento.textContent = treinando ? "Pausar Treinamento" : "Retomar Treinamento";
    });

    btnReset.addEventListener("click", () => {
      // Recria o AG com os novos par√¢metros
      algoritmoGenetico = new AlgoritmoGenetico(TAMANHO_POPULACAO, tamanhoGenoma);
      historicoMelhorFitness = [];
      historicoFitnessMedio = [];
      ambienteVisualizacao.reiniciar();
      divInfo.textContent = "Popula√ß√£o resetada.";
    });

    // Event listeners para os controles
    const popSizeSlider = document.getElementById("popSizeSlider");
    const eliteCountSlider = document.getElementById("eliteCountSlider");
    const mutationRateSlider = document.getElementById("mutationRateSlider");
    const mutationStdSlider = document.getElementById("mutationStdSlider");
    const episodesSlider = document.getElementById("episodesSlider");
    const maxStepsSlider = document.getElementById("maxStepsSlider");

    const popSizeValue = document.getElementById("popSizeValue");
    const eliteCountValue = document.getElementById("eliteCountValue");
    const mutationRateValue = document.getElementById("mutationRateValue");
    const mutationStdValue = document.getElementById("mutationStdValue");
    const episodesValue = document.getElementById("episodesValue");
    const maxStepsValue = document.getElementById("maxStepsValue");
    const applyParamsBtn = document.getElementById("applyParamsBtn");
    const pendingChangesMsg = document.getElementById("pendingChangesMsg");

    // Valores atuais aplicados
    let valoresAplicados = {
      tamanhoPopulacao: TAMANHO_POPULACAO,
      numeroElites: NUMERO_ELITES,
      taxaMutacao: TAXA_MUTACAO,
      desvioPadraoMutacao: DESVIO_PADRAO_MUTACAO,
      episodiosPorGenoma: EPISODIOS_POR_GENOMA,
      maxPassosPorEpisodio: MAX_PASSOS_POR_EPISODIO
    };

    function verificarMudancasPendentes() {
      const novoValorPop = parseInt(popSizeSlider.value);
      const novoValorElites = parseInt(eliteCountSlider.value);
      const novoValorTaxa = parseFloat(mutationRateSlider.value);
      const novoValorDesvio = parseFloat(mutationStdSlider.value);
      const novoValorEpisodios = parseInt(episodesSlider.value);
      const novoValorPassos = parseInt(maxStepsSlider.value);

      const temMudancas = 
        novoValorPop !== valoresAplicados.tamanhoPopulacao ||
        novoValorElites !== valoresAplicados.numeroElites ||
        novoValorTaxa !== valoresAplicados.taxaMutacao ||
        novoValorDesvio !== valoresAplicados.desvioPadraoMutacao ||
        novoValorEpisodios !== valoresAplicados.episodiosPorGenoma ||
        novoValorPassos !== valoresAplicados.maxPassosPorEpisodio;

      if (temMudancas) {
        pendingChangesMsg.style.display = "block";
        applyParamsBtn.disabled = false;
      } else {
        pendingChangesMsg.style.display = "none";
        applyParamsBtn.disabled = true;
      }
    }

    function aplicarParametros() {
      // Aplica os novos valores
      TAMANHO_POPULACAO = parseInt(popSizeSlider.value);
      NUMERO_ELITES = parseInt(eliteCountSlider.value);
      TAXA_MUTACAO = parseFloat(mutationRateSlider.value);
      DESVIO_PADRAO_MUTACAO = parseFloat(mutationStdSlider.value);
      EPISODIOS_POR_GENOMA = parseInt(episodesSlider.value);
      MAX_PASSOS_POR_EPISODIO = parseInt(maxStepsSlider.value);

      // Atualiza valores aplicados
      valoresAplicados = {
        tamanhoPopulacao: TAMANHO_POPULACAO,
        numeroElites: NUMERO_ELITES,
        taxaMutacao: TAXA_MUTACAO,
        desvioPadraoMutacao: DESVIO_PADRAO_MUTACAO,
        episodiosPorGenoma: EPISODIOS_POR_GENOMA,
        maxPassosPorEpisodio: MAX_PASSOS_POR_EPISODIO
      };

      // Recria o algoritmo gen√©tico com os novos par√¢metros
      algoritmoGenetico = new AlgoritmoGenetico(TAMANHO_POPULACAO, tamanhoGenoma);
      historicoMelhorFitness = [];
      historicoFitnessMedio = [];
      ambienteVisualizacao.reiniciar();

      // Esconde mensagem de mudan√ßas pendentes
      pendingChangesMsg.style.display = "none";
      applyParamsBtn.disabled = true;

      divInfo.textContent = "Par√¢metros aplicados! Popula√ß√£o reiniciada.";
    }

    popSizeSlider.addEventListener("input", (e) => {
      const novoValor = parseInt(e.target.value);
      popSizeValue.textContent = novoValor;
      
      // Garante que NUMERO_ELITES n√£o seja maior que TAMANHO_POPULACAO
      if (parseInt(eliteCountSlider.value) > novoValor) {
        const novoElite = Math.max(1, Math.floor(novoValor / 4));
        eliteCountSlider.value = novoElite;
        eliteCountValue.textContent = novoElite;
      }
      eliteCountSlider.max = Math.max(1, Math.floor(novoValor / 2));
      
      verificarMudancasPendentes();
    });

    eliteCountSlider.addEventListener("input", (e) => {
      eliteCountValue.textContent = e.target.value;
      verificarMudancasPendentes();
    });

    mutationRateSlider.addEventListener("input", (e) => {
      mutationRateValue.textContent = parseFloat(e.target.value).toFixed(2);
      verificarMudancasPendentes();
    });

    mutationStdSlider.addEventListener("input", (e) => {
      mutationStdValue.textContent = parseFloat(e.target.value).toFixed(1);
      verificarMudancasPendentes();
    });

    episodesSlider.addEventListener("input", (e) => {
      episodesValue.textContent = e.target.value;
      verificarMudancasPendentes();
    });

    maxStepsSlider.addEventListener("input", (e) => {
      maxStepsValue.textContent = e.target.value;
      verificarMudancasPendentes();
    });

    applyParamsBtn.addEventListener("click", aplicarParametros);
    
    // Inicializa o bot√£o como desabilitado (sem mudan√ßas pendentes)
    applyParamsBtn.disabled = true;

    /*************************************************
     * INICIALIZA√á√ÉO
     *************************************************/
    // Configura limites iniciais dos sliders
    eliteCountSlider.max = Math.max(1, Math.floor(TAMANHO_POPULACAO / 2));

    // Desenho inicial
    desenharRedeNeural(melhorGenoma, null);
    desenharGraficoFitness();
    ambienteVisualizacao.reiniciar();
    desenharPongPrincipal();
    ambienteJogo1.reiniciar();
    ambienteJogo2.reiniciar();
    ambienteJogo3.reiniciar();
    desenharPong(ambienteJogo1, ctxJogo1, 200, 150);
    desenharPong(ambienteJogo2, ctxJogo2, 200, 150);
    desenharPong(ambienteJogo3, ctxJogo3, 200, 150);

    // Loop de treinamento (uma gera√ß√£o a cada ~300 ms)
    setInterval(passoTreinamento, 30);

    // Atualiza genomas dos jogos adicionais periodicamente com genomas aleat√≥rios da popula√ß√£o
    setInterval(() => {
      if (algoritmoGenetico.populacao.length > 0) {
        const idx1 = Math.floor(Math.random() * algoritmoGenetico.populacao.length);
        const idx2 = Math.floor(Math.random() * algoritmoGenetico.populacao.length);
        const idx3 = Math.floor(Math.random() * algoritmoGenetico.populacao.length);
        genomaJogo1 = new Float64Array(algoritmoGenetico.populacao[idx1]);
        genomaJogo2 = new Float64Array(algoritmoGenetico.populacao[idx2]);
        genomaJogo3 = new Float64Array(algoritmoGenetico.populacao[idx3]);
      }
    }, 2000);

    // Loop de anima√ß√£o do jogo
    requestAnimationFrame(loopAnimacao);
  </script>
</body>
</html>
